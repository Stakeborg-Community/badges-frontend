{"version":3,"sources":["resources/img/bg_blur.png","enums/NFTOwnershipStatus.js","components/NFT.tsx","components/wallet.js","components/merkletree.js","App.js","reportWebVitals.js","index.js"],"names":["Owned","Symbol","Mintable","NonMintable","Unknown","Priority","s","cardsStatusComparator","a","b","priorityA","status","priorityB","NFT","props","_isMounted","useRef","React","useState","nftData","setNftData","loading","setLoading","errorMessage","setErrorMessage","fetchNFTData","useCallback","fetch","tokenId","res","ok","Error","json","data","current","image_svg","image_lg","image_sm","name","description","ownedStatus","message","useEffect","console","log","size","mintingFn","NFTCard","useDisclosure","isOpen","onOpen","onClose","button","commonImageClasses","NFTOwnershipStatus","color","className","boxShadow","backgroundColor","variant","loadingText","onClick","isLoading","isDisabled","imageModal","src","borderRadius","w","modal","isCentered","motionPreset","allowPinchZoom","maxW","href","checkIfWalletIsConnected","currentAccountSetter","connectedContractSetter","window","ethereum","switchNetworkMumbai","provider","ethers","providers","Web3Provider","signer","getSigner","contract","Contract","SeniorityBadgev2","abi","send","accounts","length","account","request","method","params","chainId","code","chainName","rpcUrls","nativeCurrency","symbol","decimals","blockExplorerUrls","alert","Merkle","this","whitelist","trees","id","groupCollapsed","leaves","getLeaves","MerkleTree","keccak256","sort","getRoot","groupEnd","tokenWhitelist","map","address","getTree","toString","leaf","getHexProof","str","toLowerCase","includes","TOKEN_IDS","App","currentAccount","setCurrentAccount","connectedContract","setConnectedContract","cardsOwnedStatus","setCardsOwnedStatus","merkle","setMerkle","cards","setCards","checkWalletConnection","wallet","then","result","getCardsOwned","updateNFTArray","mint","proof","mintBootstrapper","nftTx","mintVeteran","mintAdopter","mintSustainer","mintBeliever","hash","wait","tx","error","cardsArray","sortedCardsStatus","k","push","i","nftComponent","ownedstatus","whitelisted","isWhitelisted","balanceOf","balance","alignItems","p","mr","bg","bgGradient","value","shortened","copiable","m","height","width","border","minChildWidth","spacing","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","customTheme","extendTheme","fonts","heading","body","components","Modal","baseStyle","dialog","shadow","styles","global","backgroundImage","bg_blur","backgroundPosition","backgroundAttachment","backgroundSize","ReactDOM","render","StrictMode","theme","document","getElementById"],"mappings":"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","file":"static/js/main.1e3618a0.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/bg_blur.8f1f3050.png\";","export const Owned = Symbol(\"OWNED\");\r\nexport const Mintable = Symbol(\"MINTABLE\");\r\nexport const NonMintable = Symbol(\"NON_MINTABLE\");\r\nexport const Unknown = Symbol(\"UNKNOWN\");\r\n\r\nexport const Priority = (s) => { \r\n    switch (s) {\r\n        case Owned: return 0;\r\n        case Mintable: return 1;\r\n        case NonMintable: return 2;\r\n        case Unknown: return 999;\r\n        default: return 100000;\r\n    }\r\n}\r\n\r\nconst cardsStatusComparator = (a,b) => {\r\n    const priorityA = Priority(a.status);\r\n    const priorityB = Priority(b.status);\r\n    return  priorityA > priorityB ? 1 : (priorityA < priorityB ? -1 : 0);\r\n  }\r\n\r\nexport  const sortCards = (ownedStatus) => {\r\n    let status = []\r\n    for (let k in ownedStatus)\r\n    {\r\n      status.push({ 'id': k, 'status':ownedStatus   [k]});\r\n    }\r\n    status.sort(cardsStatusComparator);\r\n    return status;\r\n  }","import \"./NFT.css\";\r\nimport * as NFTOwnershipStatus from \"../enums/NFTOwnershipStatus.js\";\r\nimport React, { useCallback, useEffect, useRef } from 'react';\r\nimport {\r\n  Button,\r\n  Box,\r\n  Image,\r\n  Alert,\r\n  AlertIcon,\r\n} from '@chakra-ui/react';\r\nimport {\r\n  Modal,\r\n  ModalOverlay,\r\n  ModalContent,\r\n  ModalBody,\r\n  useDisclosure \r\n} from '@chakra-ui/react'\r\n\r\n\r\nexport interface NFTProps {\r\n  /**\r\n   * The id of the NFT.\r\n   */\r\n  tokenId: string;\r\n  /**\r\n   * The size of the NFT card.\r\n   */\r\n  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';\r\n   /**\r\n   * The status of the NFT ownership\r\n   */\r\n  ownedStatus: Symbol;\r\n  /**\r\n   * The function to call upon minting\r\n   */\r\n  mintingFn: Function;\r\n}\r\n\r\nexport interface NFTData {\r\n  tokenId: string;\r\n  image_svg?: string;\r\n  image_lg?: string;\r\n  image_sm?: string;\r\n  name: string | null;\r\n  description: string;\r\n  ownedStatus: Symbol;\r\n}\r\n\r\n/**\r\n * Component to fetch and display NFT data\r\n */\r\nexport const NFT = (props: NFTProps) => {\r\n  const _isMounted = useRef(true);\r\n  const [nftData, setNftData] = React.useState<NFTData>();\r\n  const [loading, setLoading] = React.useState(false);\r\n  const [errorMessage, setErrorMessage] = React.useState<string>();\r\n  const fetchNFTData = useCallback(async () => {\r\n    try {\r\n      \r\n      const res = await fetch(\"https://ipfs.io/ipfs/Qmc2qn27xNCv4RbTw5kpgA1tbogaZ5QY6MLf5uyMDUZTWW/\" + props.tokenId + \".json\");\r\n          \r\n      if (!res.ok) {\r\n        throw Error(\r\n          `Request failed with status: ${res.status}. Make sure the ipfs url is correct.`\r\n        );\r\n      }\r\n      const data = await res.json();\r\n      if (_isMounted.current) {\r\n        setNftData({\r\n          tokenId: props.tokenId,\r\n          image_svg:  data['image_svg'],\r\n          image_lg: data['image_lg'],\r\n          image_sm: data['image_sm'],\r\n          name: data.name,\r\n          description: data.description,\r\n          ownedStatus: props.ownedStatus\r\n        });\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof Error) {\r\n        setErrorMessage(error.message);\r\n      } else {\r\n        setErrorMessage('An unknown error occurred');\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    console.log(`Update on NFT ${props.tokenId} triggered. Owned status changed to ${props.ownedStatus.description}`);\r\n    _isMounted.current = true;\r\n    fetchNFTData();\r\n    return () => {\r\n      _isMounted.current = false;\r\n    };\r\n  }, [props.ownedStatus, loading]);\r\n\r\n  return <NFTCard data={nftData} errorMessage={errorMessage} size={props.size} mintingFn={props.mintingFn} loading={loading} setLoading={setLoading}/>;\r\n};\r\n\r\n/**\r\n * Private component to display an NFT given the data\r\n */\r\nexport const NFTCard = ({\r\n  data,\r\n  errorMessage = '',\r\n  size = 'lg',\r\n  mintingFn,\r\n  loading,\r\n  setLoading\r\n}: {\r\n  data: NFTData | undefined | null;\r\n  errorMessage?: string | undefined;\r\n  size: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | undefined;\r\n  mintingFn: Function;\r\n  loading: boolean;\r\n  setLoading: Function;\r\n}) => {\r\n  const name = data?.name;\r\n  const description = data?.description;\r\n  const ownedStatus = data?.ownedStatus;\r\n  const tokenId = data?.tokenId;\r\n  const displayName = name;\r\n\r\n  const { isOpen, onOpen, onClose } = useDisclosure();\r\n  const mint = () =>\r\n  {\r\n    mintingFn(tokenId, setLoading);\r\n  }\r\n\r\n\r\n  if (errorMessage) {\r\n    return (\r\n      <Alert status=\"error\">\r\n        <AlertIcon />\r\n        {errorMessage}\r\n      </Alert>\r\n    );\r\n  }\r\n\r\n  let commonImageClasses = ownedStatus?.description;\r\n  let button;\r\n  if (ownedStatus !== NFTOwnershipStatus.Owned && tokenId != '69420')\r\n  {\r\n    button = <Button color='white' className=\"nftButton\" boxShadow='md' backgroundColor='#0c8af2' variant='solid'  loadingText='Minting...'  onClick={mint} isLoading={loading} isDisabled={ownedStatus === NFTOwnershipStatus.NonMintable}>\r\n              Mint\r\n            </Button>;\r\n  }\r\n  const image = <Image className={commonImageClasses  + ' hoverglow'}  src={data?.image_lg} borderRadius=\"2xl\" w={size} loading=\"lazy\" />;\r\n  const imageModal = <Image className={commonImageClasses}  src={data?.image_lg} borderRadius=\"2xl\" w={size} loading=\"lazy\" />;\r\n\r\n\r\n\r\n\r\n  const modal = <Modal isOpen={isOpen} onClose={onClose} size={size} isCentered motionPreset=\"scale\" allowPinchZoom>\r\n        <ModalOverlay/>\r\n        <ModalContent>\r\n          <ModalBody>\r\n            {imageModal}\r\n          </ModalBody>\r\n        </ModalContent>\r\n      </Modal>\r\n\r\n  return (\r\n      <Box maxW={size} borderRadius='lg' >\r\n        \r\n        <a href=\"#\" onClick={onOpen}>\r\n          {imageModal}\r\n          {modal}\r\n        </a>\r\n\r\n        {button}\r\n        \r\n      </Box>\r\n\r\n  );\r\n};","import { ethers } from \"ethers\";\r\nimport SeniorityBadgev2 from \"../json/SeniorityBadge-v2.json\";\r\n\r\nconst CONTRACT_ADDRESS_V2 = \"0x97E4743723570De6aEEd04560DB765CAAc8FD12F\";\r\n\r\nexport const checkIfWalletIsConnected = async (currentAccountSetter, connectedContractSetter) => {\r\n    const {ethereum} = window;  \r\n    if (!ethereum) {\r\n        console.log(\"Make sure you have metamask\");\r\n        return;\r\n    } else {\r\n        console.log(\"We have the ethereum object\", ethereum);\r\n    }\r\n    // Check if metamask is connected to Mumbai. Trigger network switch if not\r\n    await switchNetworkMumbai();\r\n\r\n    // Connect to contract\r\n    const provider = new ethers.providers.Web3Provider(ethereum);\r\n    const signer = provider.getSigner();\r\n    const contract = new ethers.Contract(CONTRACT_ADDRESS_V2, SeniorityBadgev2.abi, signer);\r\n    await connectedContractSetter(contract);\r\n\r\n    const accounts = await provider.send(\"eth_requestAccounts\", []);\r\n\r\n    if (accounts.length !== 0) {\r\n        const account = accounts[0];\r\n        console.log(\"Found authorized account:\", account);\r\n        await currentAccountSetter(account);\r\n    }\r\n\r\n    \r\n}\r\n\r\nconst switchNetworkMumbai = async () => {\r\n    try {\r\n        await window.ethereum.request({\r\n        method: \"wallet_switchEthereumChain\",\r\n        params: [{ chainId: \"0x13881\" }],\r\n        });\r\n    } catch (error) {\r\n        if (error.code === 4902) {\r\n        try {\r\n            await window.ethereum.request({\r\n            method: \"wallet_addEthereumChain\",\r\n            params: [\r\n                {\r\n                chainId: \"0x13881\",\r\n                chainName: \"Mumbai\",\r\n                rpcUrls: [\"https://matic-mumbai.chainstacklabs.com\"],\r\n                nativeCurrency: {\r\n                    name: \"Matic\",\r\n                    symbol: \"Matic\",\r\n                    decimals: 18,\r\n                },\r\n                blockExplorerUrls: [\"https://explorer-mumbai.maticvigil.com\"],\r\n                },\r\n            ],\r\n            });\r\n        } catch (error) {\r\n            alert(error.message);\r\n        }\r\n        }\r\n    }\r\n}","import {MerkleTree} from \"merkletreejs\";\r\nimport keccak256 from \"keccak256\";\r\nimport whitelist from \"../json/whitelist.json\";\r\n\r\nexport default class Merkle {\r\n\r\n    constructor() {\r\n        this.whitelist = whitelist;\r\n        this.trees = [];\r\n        return (async () => {\r\n            // try {      \r\n            //     const res = await fetch(\"https://ipfs.io/ipfs/QmaLwggVBJhqSmQhdDPa4zipug8BHME3PV4JPVbsXxRBvN/whitelist.json\");\r\n                    \r\n            //     if (!res.ok) {\r\n            //       throw Error(\r\n            //         `Request failed with status: ${res.status}. Make sure the ipfs url is correct.`\r\n            //       );\r\n            //     }\r\n            //     const data = await res.json();\r\n                \r\n            //     console.log(\"Whitelist received\", data);\r\n            //     this.whitelist = data;\r\n            // } catch (error) {\r\n            //     console.error(error);\r\n            // }\r\n            console.groupCollapsed(\"Merkle root for all tokens:\");\r\n            for (let id in this.whitelist.tokenId)\r\n            {\r\n                const leaves = this.getLeaves(id);\r\n                this.trees[id] = new MerkleTree(leaves, keccak256, {sort: true});\r\n                console.log(id, this.getRoot(id));\r\n            }\r\n            console.groupEnd();\r\n\r\n            return this;\r\n        })();       \r\n    }\r\n\r\n    tokenWhitelist(tokenId) {\r\n        return this.whitelist.tokenId[tokenId] ?? [];\r\n    }\r\n\r\n    getLeaves(tokenId) {\r\n        const wl = this.tokenWhitelist(tokenId);\r\n        return wl.map(address => keccak256(address));\r\n    } \r\n\r\n    getTree(tokenId) {\r\n        return this.trees[tokenId];\r\n    }\r\n\r\n    getRoot(tokenId) {\r\n        const tree = this.getTree(tokenId);\r\n        return tree.getRoot().toString('hex');\r\n    }\r\n\r\n    getHexProof(address, tokenId) {\r\n        const leaf = keccak256(address);\r\n        const tree = this.getTree(tokenId);\r\n        return tree.getHexProof(leaf)\r\n    }\r\n\r\n    isWhitelisted(address, tokenId) {\r\n        const wl = this.tokenWhitelist(tokenId).map((str) => str.toLowerCase());\r\n        return wl.includes(address.toLowerCase());\r\n    }\r\n}","\r\nimport './App.css';\r\nimport { useState, useEffect } from \"react\";\r\n\r\nimport { Container, SimpleGrid, Box, Button, Heading, Flex, Spacer } from '@chakra-ui/react';\r\nimport { NFT } from \"./components/NFT.tsx\";\r\nimport { Address } from \"@web3-ui/components\";\r\nimport * as NFTOwnershipStatus from \"./enums/NFTOwnershipStatus\";\r\nimport * as wallet from \"./components/wallet.js\";\r\nimport Merkle from \"./components/merkletree.js\";\r\n\r\nconst TOKEN_IDS = [0,1,2,3,4,69420]; // This spits out warnings in log but it's fine, we do not care about the unknwon badges\r\n\r\n\r\nfunction App() {\r\n/* Lesson learned the hard way: Change state variables only using their set function */\r\n  const [currentAccount, setCurrentAccount] = useState(\"\");\r\n  const [connectedContract, setConnectedContract] = useState(null);\r\n  const [cardsOwnedStatus, setCardsOwnedStatus] = useState(null);\r\n  const [merkle, setMerkle] = useState(null);\r\n\r\n  // Cards owned by the connected account\r\n  const [cards, setCards] = useState([]);\r\n\r\n\r\n  // Helper middleware function\r\n  const checkWalletConnection = async () =>\r\n  {\r\n    await wallet.checkIfWalletIsConnected(setCurrentAccount,setConnectedContract);\r\n  }\r\n\r\n  // Initialise merkle trees and do wallet connection\r\n  useEffect( () => {\r\n    new Merkle().then((result) => setMerkle(result));\r\n    checkWalletConnection();\r\n  }, []);\r\n\r\n\r\n  // Trigget getting of badges owned only when both the contract and merkel instance has been initialised\r\n  useEffect(() => {\r\n    if (connectedContract !== null && merkle !== null && currentAccount != \"\") {\r\n      getCardsOwned();\r\n    }\r\n  }, [connectedContract, currentAccount, merkle])\r\n\r\n\r\n  // Trigger the creation of the badges for rendering only after the ownership of the badges has been decided\r\n  useEffect( () => {\r\n    if (cardsOwnedStatus !== null) {\r\n      updateNFTArray();\r\n    }\r\n  }, [cardsOwnedStatus]);   \r\n  \r\n\r\n  const mint = async (tokenId, setLoading) => {\r\n    console.log(\"trying to mint: \", tokenId); \r\n    await checkWalletConnection();\r\n    let nftTx;\r\n    let tx;\r\n\r\n    try {\r\n      const proof = merkle.getHexProof(currentAccount, tokenId);\r\n      \r\n      switch (tokenId) {\r\n        case 0:\r\n          nftTx = await connectedContract.mintBootstrapper(proof);\r\n          break;\r\n        case 1:\r\n          nftTx = await connectedContract.mintVeteran(proof);\r\n          break;\r\n        case 2:\r\n          nftTx = await connectedContract.mintAdopter(proof);\r\n          break;\r\n        case 3:\r\n          nftTx = await connectedContract.mintSustainer(proof);\r\n          break;\r\n        case 4:\r\n          nftTx = await connectedContract.mintBeliever(proof);\r\n          break;\r\n        default:\r\n          alert(\"You are trying to mint a non-existent token.\");\r\n      }\r\n      \r\n\t\t\tconsole.log('Minting....', nftTx.hash);\r\n      setLoading(true);\r\n    } catch (error) {\r\n      alert((error.data ? error.data.message : null) ?? error.message ?? \"Unsupported error\");\r\n      return;\r\n    } \r\n\r\n\r\n    try{    \r\n      tx = await nftTx.wait();\r\n      console.log('Minted!', tx);  \r\n    } catch (error) {\r\n      console.error(`Failed to mint token ${tokenId} for address ${currentAccount}`);\r\n      alert((error.data ? error.data.message : null) ?? error.message ?? \"Unsupported error\");\r\n    }\r\n    finally {\r\n      getCardsOwned();\r\n    }\r\n  \r\n}\r\n  \r\n \r\n\r\n  const updateNFTArray = () => {\r\n    let cardsArray = [];\r\n    let sortedCardsStatus = NFTOwnershipStatus.sortCards(cardsOwnedStatus);\r\n    for (let i=0; i<sortedCardsStatus.length; i++) {\r\n      let nftComponent = <NFT key={sortedCardsStatus[i].id} tokenId={sortedCardsStatus[i].id} ownedStatus={sortedCardsStatus[i].status} mintingFn={mint}></NFT>;\r\n      cardsArray.push(nftComponent);\r\n    }\r\n    console.log(\"Create nft arrays\");\r\n    setCards(cardsArray);\r\n  }\r\n\r\n  const getCardsOwned = async () => {\r\n    console.groupCollapsed('Contract instance');\r\n    console.log(connectedContract);\r\n    console.groupEnd();\r\n    console.groupCollapsed('Owned tokens');\r\n    let ownedstatus = {};\r\n    for (let i=0; i<TOKEN_IDS.length; i++) {\r\n      const id = TOKEN_IDS[i];\r\n      const whitelisted = merkle.isWhitelisted(currentAccount, id);\r\n      \r\n      try {\r\n        const balance = await connectedContract.balanceOf(currentAccount, id)\r\n        console.log(`${id}: ${balance.toString()}`);\r\n        if (balance.toString() !== \"0\") {\r\n          ownedstatus[id] = NFTOwnershipStatus.Owned;\r\n        } \r\n        else if (whitelisted) {\r\n          ownedstatus[id] = NFTOwnershipStatus.Mintable;\r\n        } else {\r\n          ownedstatus[id] = NFTOwnershipStatus.NonMintable;\r\n        }\r\n      \r\n      } catch (error) {\r\n        console.error(`Failed to get balance of token ${id} for address ${currentAccount}`);\r\n        console.error(error);\r\n        console.groupEnd();\r\n        return;\r\n      }\r\n    }\r\n    console.groupEnd();  \r\n    setCardsOwnedStatus(ownedstatus);    \r\n  }    \r\n\r\n\r\n  // Render this when the wallet is not connected\r\n  const renderNotConnectedContainer = () => (\r\n    <Container>\r\n      <Button\r\n        onClick={checkWalletConnection}\r\n        size='md'\r\n        height='48px'\r\n        width='200px'\r\n        border='2px'\r\n      >\r\n      Connect to Wallet\r\n      </Button>\r\n    </Container>\r\n    \r\n  );\r\n  \r\n  // Render this when the wallet is connected\r\n  const renderBadgeContainer = () => (\r\n\r\n    <Container maxW='container.xl' className=\"badge-container\">\r\n          <SimpleGrid minChildWidth='220px' spacing='30px'>\r\n            {cards}\r\n          </SimpleGrid>\r\n    </Container>\r\n  );\r\n\r\n  const renderAddressContainer = () => (\r\n    <Box alignItems='center' w='200px' p='10px' mr='30px' bg='tomato' color='white' borderRadius='lg' boxShadow='lg' bgGradient=\"linear(to-l, #3c4bbb, #00003b)\" >\r\n        <Address value={currentAccount} shortened copiable></Address> \r\n    </Box>\r\n  )\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Flex>\r\n        <Spacer />\r\n        {currentAccount !== \"\" ? renderAddressContainer() : null}\r\n      </Flex>\r\n      <Heading  className='circle' size=\"2xl\" m='50px' color='#0e126e' > Community Achievements </Heading>\r\n      <div >\r\n        {currentAccount === \"\" ? renderNotConnectedContainer() : renderBadgeContainer()}\r\n      </div>\r\n     \r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport bg_blur from './resources/img/bg_blur.png'\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport { ChakraProvider } from '@chakra-ui/react'\r\nimport { Provider } from '@web3-ui/components';\r\nimport { extendTheme } from \"@chakra-ui/react\"\r\n\r\nconst customTheme = extendTheme({\r\n  fonts: {\r\n    heading: 'HeadingFont',\r\n    body: 'BodyFont'\r\n  },\r\n  components: {\r\n    Modal: {\r\n      baseStyle: (props) => ({\r\n        dialog: {\r\n          bg: 'rgba(0, 0, 0, 0.0)',\r\n          shadow: 'none'\r\n        }\r\n      })\r\n    }\r\n  },\r\n  styles: {\r\n    global: (props) => ({\r\n      body: {\r\n        backgroundImage: bg_blur,\r\n        backgroundPosition: 'no-repeat',\r\n        backgroundAttachment: 'fixed',\r\n        backgroundSize: 'cover'\r\n      }\r\n    })\r\n  },\r\n})\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider theme={customTheme}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('stakeborg-badges')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}