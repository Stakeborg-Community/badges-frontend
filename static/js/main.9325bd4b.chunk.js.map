{"version":3,"sources":["components/NFTOwnershipStatus.js","components/NFT.tsx","whitelisting/merkletree.js","App.js","reportWebVitals.js","index.js"],"names":["Owned","Symbol","Mintable","NonMintable","NFT","props","_isMounted","useRef","React","useState","nftData","setNftData","errorMessage","setErrorMessage","fetchNFTData","useCallback","a","fetch","tokenId","res","ok","Error","status","json","data","current","imageUrl","image","name","description","ownedStatus","message","useEffect","console","log","size","mintingFn","NFTCard","button","imageClasses","NFTOwnershipStatus","color","backgroundColor","variant","onClick","isDisabled","maxW","borderRadius","overflow","boxShadow","href","className","src","w","tokenWhitelist","whitelist","getTree","leaves","map","address","keccak256","getLeaves","MerkleTree","sort","getProof","leaf","x","toString","buf2hex","isWhitelisted","str","toLowerCase","includes","TOKEN_IDS","i","length","getRoot","App","currentAccount","setCurrentAccount","setSigner","connectedContract","setConnectedContract","cardsOwnedStatus","setCardsOwnedStatus","ownedCards","setOwnedCards","mintableCards","setMintableCards","nonMintableCards","setNonMintableCards","mint","checkIfWalletIsConnected","proof","Merkle","mintBootstrapper","nftTx","mintVeteran","mintAdopter","mintSustainer","mintBeliever","hash","wait","tx","error","alert","getCardsOwned","updateNFTArrays","ownedCardsArray","nonMintableCardsArray","mintableCardsArray","id","nftComponent","push","ownedstatus","whitelisted","balanceOf","balance","window","ethereum","switchNetworkMumbai","request","method","accounts","account","provider","ethers","providers","Web3Provider","signer","getSigner","contract","Contract","SeniorityBadgev2","abi","connectWallet","params","chainId","code","chainName","rpcUrls","nativeCurrency","symbol","decimals","blockExplorerUrls","alignItems","p","mr","bg","bgGradient","value","shortened","copiable","m","height","width","border","minChildWidth","spacing","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9325bd4b.chunk.js","sourcesContent":["export const Owned = Symbol(\"OWNED\");\r\nexport const Mintable = Symbol(\"MINTABLE\");\r\nexport const NonMintable = Symbol(\"NON_MINTABLE\");","import \"./NFT.css\";\r\nimport * as NFTOwnershipStatus from \"../components/NFTOwnershipStatus\";\r\nimport React, { useCallback, useEffect, useRef } from 'react';\r\nimport {\r\n  Button,\r\n  Box,\r\n  Image,\r\n  Alert,\r\n  AlertIcon,\r\n} from '@chakra-ui/react';\r\nimport {  \r\n  CopyIcon\r\n} from '@chakra-ui/icons';\r\n\r\n\r\n\r\nexport interface NFTProps {\r\n  /**\r\n   * The id of the NFT.\r\n   */\r\n  tokenId: string;\r\n  /**\r\n   * The size of the NFT card.\r\n   */\r\n  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';\r\n   /**\r\n   * The status of the NFT ownership\r\n   */\r\n  ownedStatus: Symbol;\r\n  /**\r\n   * The function to call upon minting\r\n   */\r\n  mintingFn: Function;\r\n}\r\n\r\nexport interface NFTData {\r\n  tokenId: string;\r\n  imageUrl?: string;\r\n  name: string | null;\r\n  description: string;\r\n  ownedStatus: Symbol;\r\n}\r\n\r\n/**\r\n * Component to fetch and display NFT data\r\n */\r\nexport const NFT = (props: NFTProps) => {\r\n  const _isMounted = useRef(true);\r\n  const [nftData, setNftData] = React.useState<NFTData>();\r\n  const [errorMessage, setErrorMessage] = React.useState<string>();\r\n  const fetchNFTData = useCallback(async () => {\r\n    try {\r\n      \r\n      const res = await fetch(\"https://ipfs.io/ipfs/QmbjoafeN3Xr1bjeyP4xEKtr2CAWWXxekq1PCY3rKv3esA/\" + props.tokenId + \".json\");\r\n          \r\n      if (!res.ok) {\r\n        throw Error(\r\n          `Request failed with status: ${res.status}. Make sure the ipfs url is correct.`\r\n        );\r\n      }\r\n      const data = await res.json();\r\n      if (_isMounted.current) {\r\n        setNftData({\r\n          tokenId: props.tokenId,\r\n          imageUrl: data.image,\r\n          name: data.name,\r\n          description: data.description,\r\n          ownedStatus: props.ownedStatus\r\n        });\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof Error) {\r\n        setErrorMessage(error.message);\r\n      } else {\r\n        setErrorMessage('An unknown error occurred');\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    console.log(`Update on NFT ${props.tokenId} triggered. Owned status changed to ${props.ownedStatus.description}`);\r\n    _isMounted.current = true;\r\n    fetchNFTData();\r\n    return () => {\r\n      _isMounted.current = false;\r\n    };\r\n  }, [props.ownedStatus]);\r\n\r\n  return <NFTCard data={nftData} errorMessage={errorMessage} size={props.size} mintingFn={props.mintingFn} />;\r\n};\r\n\r\n/**\r\n * Private component to display an NFT given the data\r\n */\r\nexport const NFTCard = ({\r\n  data,\r\n  errorMessage = '',\r\n  size = 'lg',\r\n  mintingFn,\r\n}: {\r\n  data: NFTData | undefined | null;\r\n  errorMessage?: string | undefined;\r\n  size: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | undefined;\r\n  mintingFn: Function;\r\n}) => {\r\n  const name = data?.name;\r\n  const imageUrl = data?.imageUrl;\r\n  const description = data?.description;\r\n  const ownedStatus = data?.ownedStatus;\r\n  const tokenId = data?.tokenId;\r\n  const displayName = name;\r\n\r\n  const mint = () =>\r\n  {\r\n    mintingFn(tokenId);\r\n  }\r\n\r\n  if (errorMessage) {\r\n    return (\r\n      <Alert status=\"error\">\r\n        <AlertIcon />\r\n        {errorMessage}\r\n      </Alert>\r\n    );\r\n  }\r\n\r\n  let imageClasses = ownedStatus?.description;\r\n  let button;\r\n  if (ownedStatus !== NFTOwnershipStatus.Owned)\r\n  {\r\n    button = <Button color='white' backgroundColor='#0c8af2' variant='solid' onClick={mint} isDisabled={ownedStatus === NFTOwnershipStatus.NonMintable} >\r\n              Mint\r\n            </Button>;\r\n  }\r\n\r\n  return (\r\n      <Box maxW={size} borderRadius='lg' overflow=\"hidden\" boxShadow='0px 0px 0px yellow' >\r\n        <a href=\"#\"><Image className={imageClasses}  src={imageUrl} borderRadius=\"lg\" w={size} /></a>\r\n        {button}\r\n      </Box>\r\n\r\n  );\r\n};","import {MerkleTree} from \"merkletreejs\";\r\nimport keccak256 from \"keccak256\";\r\nimport whitelist from \"./whitelist.json\";\r\n\r\n //TODO: precalculate the merkle trees, do not do it on request, but rather on load\r\n const tokenWhitelist = (tokenId) => {\r\n    return whitelist.tokenId[tokenId];\r\n}\r\n\r\nconst getLeaves = (tokenId) => {\r\n    const wl = tokenWhitelist(tokenId);\r\n    return wl.map(address => keccak256(address));\r\n} \r\n\r\nconst getTree = (tokenId) => {\r\n    const leaves = getLeaves(tokenId);\r\n    return new MerkleTree(leaves, keccak256, {sort: true});\r\n}\r\n\r\nconst getRoot = (tokenId) => {\r\n    const tree = getTree(tokenId);\r\n    return tree.getRoot().toString('hex');\r\n}\r\n\r\nconst buf2hex = x => '0x'+x.toString('hex')\r\n\r\nconst getProof = (address, tokenId) => {\r\n    const leaf = keccak256(address);\r\n    const tree = getTree(tokenId);\r\n    return tree.getProof(leaf).map(x => buf2hex(x.data))\r\n}\r\n\r\nconst isWhitelisted = (address, tokenId) => {\r\n    const wl = tokenWhitelist(tokenId).map((str) => str.toLowerCase());\r\n    return wl.includes(address.toLowerCase());\r\n}\r\n\r\nexport {\r\n    getProof,\r\n    getLeaves,\r\n    tokenWhitelist,\r\n    getTree, \r\n    getRoot,\r\n    whitelist,\r\n    isWhitelisted\r\n}","import { ethers } from \"ethers\";\r\nimport SeniorityBadge from \"./utils/SeniorityBadge.json\";\r\nimport SeniorityBadgev2 from \"./utils/SeniorityBadge-v2.json\";\r\nimport './App.css';\r\nimport { useState, useEffect } from \"react\";\r\n\r\nimport { Container, SimpleGrid, Box, Button, Text, Heading, Flex, Spacer, Spinner } from '@chakra-ui/react';\r\nimport { NFT } from \"./components/NFT.tsx\";\r\nimport { Address } from \"@web3-ui/components\";\r\nimport * as NFTOwnershipStatus from \"./components/NFTOwnershipStatus\";\r\nimport * as Merkle from \"./whitelisting/merkletree.js\";\r\n\r\nconst CONTRACT_ADDRESS = \"0xe541fe43f74c3C2111D2499789Dc16808E355a9C\";\r\nconst CONTRACT_ADDRESS_V2 = \"0x97E4743723570De6aEEd04560DB765CAAc8FD12F\";\r\nconst TOKEN_IDS = [0,1,2,3,4];\r\n\r\nconsole.log(\"Merkle root for all tokens:\");\r\nfor (let i=0; i<TOKEN_IDS.length; i++)\r\n{\r\n  console.log(TOKEN_IDS[i], Merkle.getRoot(TOKEN_IDS[i]));\r\n}\r\n\r\nfunction App() {\r\n/* Lesson learned the hard way: Change state variables only using their set function */\r\n  const [currentAccount, setCurrentAccount] = useState(\"\");\r\n  const [signer, setSigner] = useState(null);\r\n  const [connectedContract, setConnectedContract] = useState(null);\r\n  const [cardsOwnedStatus, setCardsOwnedStatus] = useState(null);\r\n\r\n  // Cards owned by the connected account\r\n  const [ownedCards, setOwnedCards] = useState([]);\r\n  // Cards which are whitelisted for the connected account and can be minted\r\n  const [mintableCards, setMintableCards] = useState([]);\r\n  // Cards which cannot be minted yet\r\n  const [nonMintableCards, setNonMintableCards] = useState([]);\r\n\r\n  const mint = async (tokenId) => {\r\n    console.log(\"trying to mint: \", tokenId); \r\n    checkIfWalletIsConnected();\r\n\r\n    try {\r\n      const proof = Merkle.getProof(currentAccount, tokenId);\r\n      let nftTx;\r\n\r\n      switch (tokenId) {\r\n        case 0:\r\n          nftTx = await connectedContract.mintBootstrapper(proof);\r\n          break;\r\n        case 1:\r\n          nftTx = await connectedContract.mintVeteran(proof);\r\n          break;\r\n        case 2:\r\n          nftTx = await connectedContract.mintAdopter(proof);\r\n          break;\r\n        case 3:\r\n          nftTx = await connectedContract.mintSustainer(proof);\r\n          break;\r\n        case 4:\r\n          nftTx = await connectedContract.mintBeliever(proof);\r\n          break;\r\n      }\r\n      \r\n\t\t\tconsole.log('Mining....', nftTx.hash);\r\n      let tx = await nftTx.wait();\r\n      console.log('Minted!', tx);\r\n        \r\n    } catch (error) {\r\n      console.error(`Failed to mint token ${tokenId} for address ${currentAccount}`);\r\n      alert(error.data.message);\r\n    }\r\n    finally {\r\n      getCardsOwned();\r\n    }\r\n  }\r\n\r\n  useEffect( () => {\r\n    checkIfWalletIsConnected();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (connectedContract !== null) {\r\n      getCardsOwned();\r\n    }\r\n  }, [connectedContract])\r\n\r\n  useEffect( () => {\r\n    if (cardsOwnedStatus !== null) {\r\n      updateNFTArrays();\r\n    }\r\n  }, [cardsOwnedStatus]);  \r\n\r\n  const updateNFTArrays = () => {\r\n    let ownedCardsArray = [];\r\n    let nonMintableCardsArray = [];\r\n    let mintableCardsArray = [];\r\n\r\n    for (let i=0; i<TOKEN_IDS.length; i++) {\r\n      let id = TOKEN_IDS[i];\r\n      let nftComponent = <NFT key={id} tokenId={id} ownedStatus={cardsOwnedStatus[id]} mintingFn={mint}></NFT>;\r\n      switch (cardsOwnedStatus[id]) {\r\n        case NFTOwnershipStatus.Owned:\r\n          ownedCardsArray.push(nftComponent);\r\n          break;\r\n\r\n        case NFTOwnershipStatus.Mintable:\r\n          mintableCardsArray.push(nftComponent);\r\n          break;\r\n          \r\n        case NFTOwnershipStatus.NonMintable:\r\n          nonMintableCardsArray.push(nftComponent);\r\n          break;\r\n      }\r\n    }\r\n    console.log(\"Create nft arrays\");\r\n    setOwnedCards(ownedCardsArray);\r\n    setMintableCards(mintableCardsArray);\r\n    setNonMintableCards(nonMintableCardsArray);\r\n  }\r\n\r\n  const getCardsOwned = async () => {\r\n    console.log('Contract instance:');\r\n    console.log(connectedContract);\r\n    let ownedstatus = {};\r\n    for (let i=0; i<TOKEN_IDS.length; i++) {\r\n      const id = TOKEN_IDS[i];\r\n      const whitelisted = Merkle.isWhitelisted(currentAccount, id);\r\n      \r\n      try {\r\n        const balance = await connectedContract.balanceOf(currentAccount, id)\r\n        console.log(`Owned token ${id}: ${balance.toString()}`);\r\n        if (balance.toString() !== \"0\") {\r\n          ownedstatus[id] = NFTOwnershipStatus.Owned;\r\n        } \r\n        else if (whitelisted) {\r\n          ownedstatus[id] = NFTOwnershipStatus.Mintable;\r\n        } else {\r\n          ownedstatus[id] = NFTOwnershipStatus.NonMintable;\r\n        }\r\n      \r\n      } catch (error) {\r\n        console.error(`Failed to get balance of token ${id} for address ${currentAccount}`);\r\n        console.error(error);\r\n        return;\r\n      }\r\n    }  \r\n    setCardsOwnedStatus(ownedstatus);    \r\n  }   \r\n\r\n\r\n  const checkIfWalletIsConnected = async () => {\r\n    const {ethereum} = window;\r\n  \r\n    if (!ethereum) {\r\n      console.log(\"Make sure you have metamask\");\r\n      return;\r\n    } else {\r\n      console.log(\"We have the ethereum object\", ethereum);\r\n    }\r\n    // Check if metamask is connected to Mumbai. Trigger network switch if not\r\n    await switchNetworkMumbai();\r\n    const accounts = await ethereum.request({method: 'eth_accounts'});\r\n\r\n    if (accounts.length !== 0) {\r\n      const account = accounts[0];\r\n      console.log(\"Found authorized account:\", account);\r\n      setCurrentAccount(account);\r\n    }\r\n\r\n    // Connect to contract\r\n    const provider = new ethers.providers.Web3Provider(ethereum);\r\n    const signer = provider.getSigner();\r\n    const contract = new ethers.Contract(CONTRACT_ADDRESS_V2, SeniorityBadgev2.abi, signer);\r\n    setSigner(signer);\r\n    setConnectedContract(contract);\r\n  }\r\n \r\n  \r\n\r\n\r\n  const connectWallet = async () => {\r\n    try {\r\n      const {ethereum} = window;\r\n      if ( !ethereum ) {\r\n        alert(\"Get Metamask!\");\r\n        return;\r\n      }\r\n\r\n      await switchNetworkMumbai();\r\n\r\n      const accounts = await ethereum.request({method: \"eth_requestAccounts\"});\r\n      console.log(\"Connected\", accounts[0]);\r\n      setCurrentAccount(accounts[0]);\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n  const switchNetworkMumbai = async () => {\r\n    try {\r\n      await window.ethereum.request({\r\n        method: \"wallet_switchEthereumChain\",\r\n        params: [{ chainId: \"0x13881\" }],\r\n      });\r\n    } catch (error) {\r\n      if (error.code === 4902) {\r\n        try {\r\n          await window.ethereum.request({\r\n            method: \"wallet_addEthereumChain\",\r\n            params: [\r\n              {\r\n                chainId: \"0x13881\",\r\n                chainName: \"Mumbai\",\r\n                rpcUrls: [\"https://matic-mumbai.chainstacklabs.com\"],\r\n                nativeCurrency: {\r\n                  name: \"Matic\",\r\n                  symbol: \"Matic\",\r\n                  decimals: 18,\r\n                },\r\n                blockExplorerUrls: [\"https://explorer-mumbai.maticvigil.com\"],\r\n              },\r\n            ],\r\n          });\r\n        } catch (error) {\r\n          alert(error.message);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Render this when the wallet is not connected\r\n  const renderNotConnectedContainer = () => (\r\n    <Container>\r\n      <Button\r\n        onClick={connectWallet}\r\n        size='md'\r\n        height='48px'\r\n        width='200px'\r\n        border='2px'\r\n      >\r\n      Connect to Wallet\r\n      </Button>\r\n    </Container>\r\n    \r\n  );\r\n  \r\n  // Render this when the wallet is connected\r\n  const renderBadgeContainer = () => (\r\n\r\n    <Container maxW='container.xl' className=\"badge-container\">\r\n          <SimpleGrid minChildWidth='150px' spacing='30px'>\r\n            {ownedCards}\r\n            {mintableCards}\r\n            {nonMintableCards}\r\n          </SimpleGrid>\r\n    </Container>\r\n  );\r\n\r\n  const renderAddressContainer = () => (\r\n    <Box alignItems='center' w='200px' p='10px' mr='30px' bg='tomato' color='white' borderRadius='lg' boxShadow='lg' bgGradient=\"linear(to-l, #3c4bbb, #00003b)\" >\r\n        <Address value={currentAccount} shortened copiable></Address> \r\n    </Box>\r\n  )\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Flex>\r\n        <Spacer />\r\n        {currentAccount !== \"\" ? renderAddressContainer() : null}\r\n      </Flex>\r\n      <Heading  className='cirlce pulse' size=\"2xl\" m='50px' color='#0e126e' > Community Achievements </Heading>\r\n      <div >\r\n        {currentAccount === \"\" ? renderNotConnectedContainer() : renderBadgeContainer()}\r\n      </div>\r\n     \r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport { ChakraProvider } from '@chakra-ui/react'\r\nimport { Provider } from '@web3-ui/components';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('stakeborg-badges')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}